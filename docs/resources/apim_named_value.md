---
# generated by https://github.com/hashicorp/terraform-plugin-docs
page_title: "az-confidential_apim_named_value Resource - az-confidential"
subcategory: ""
description: |-
  Creates a named value in API Management without revealing its value in state.
  This resource fills in a gap where a named value is sensitive enough to be avoided being stored
  in the Terraform configuration in the clear yet not sensitive enough to be placed in the key vault.
  An example of such a scenario is a shared code repository containing routing configuration
  belonging to different teams. The purpose of adding this protection here would be to allow the
  teams to collaborate without exposing routing internals. Adopting this resource can help avoiding
  a churn of secrets in Key Vault.
  How to create the ciphertext
  The ciphertext (i.e. the value of the content attribute) can be created with the encrypt_apim_named_value function.
  This function will generate only the ciphertext. A complimentary tfgen https://github.com/aliakseiyanchuk/terraform-provider-az-confidential-tfgen
  tool can used to generate both ciphertext
  and the Terraform code template.
  As a pre-requisite, you need to have a public key of the key-encryption key the action provider instance will
  be using.
  Example how to create ciphertext using Terraform provider
  Consider the following example that creates a ciphertext that can be used for test and acceptance purposes for
  next year when the content should not be read more that 50 times:
  
  variable "content" {
    type        = string
    description = "Named value to be wraoped"
  }
  
  variable "public_key_file" {
    type        = string
    description = "Public key file"
  }
  
  locals {
    public_key = file(var.public_key_file)
  }
  
  output "encrypted_named_value" {
    value = provider::az-confidential::encrypt_apim_named_value(
      var.content,
      {
        az_subscription_id  = "123421"
        resource_group      = "rg"
        api_management_name = "apim"
        name : "namedValue123",
      },
      {
        create_limit  = "72h"
        expires_after = 365
        num_uses      = 50
        provider_constraints = toset(["test", "acceptance"])
      },
      local.public_key
    )
  }
  
  
  Please refer to the encrypt_apim_named_value function documentation ../functions/encrypt_apim_named_value.md
  for the description of the parameters the function accepts.
  Create ciphertext using tfgen tool
  The ciphertext as well as a complete Terraform datasource template can be obtained using the tfgen command-line tool
  (see source code https://github.com/aliakseiyanchuk/terraform-provider-az-confidential-tfgen.)
  The prompt equivalent to the function invocation illustrated above is:
  
  tfgen -pubkey [path to the public key] \
    -provider-constraints demo,acceptance \
    -num-uses 50 \
    apim named_value
  
  The tool will prompt for the interactive content input. Further options can be obtained by tfgen -help and
  tfgen apim named_value -help commands.
---

# az-confidential_apim_named_value (Resource)

Creates a named value in API Management without revealing its value in state.

This resource fills in a gap where a named value is sensitive enough to be avoided being stored
in the Terraform configuration in the clear yet not sensitive enough to be placed in the key vault.

An example of such a scenario is a shared code repository containing routing configuration
belonging to different teams. The purpose of adding this protection here would be to allow the
teams to collaborate without exposing routing internals. Adopting this resource can help avoiding
a churn of secrets in Key Vault.

## How to create the ciphertext
The ciphertext (i.e. the value of the `content` attribute) can be created with the `encrypt_apim_named_value` function.
This function will generate only the ciphertext. A complimentary [`tfgen`](https://github.com/aliakseiyanchuk/terraform-provider-az-confidential-tfgen)
tool can used to generate both ciphertext
and the Terraform code template.

As a pre-requisite, you need to have a public key of the key-encryption key the action provider instance will
be using.

### Example how to create ciphertext using Terraform provider

Consider the following example that creates a ciphertext that can be used for test and acceptance purposes for
next year when the content should not be read more that 50 times:

```terraform
variable "content" {
  type        = string
  description = "Named value to be wraoped"
}

variable "public_key_file" {
  type        = string
  description = "Public key file"
}

locals {
  public_key = file(var.public_key_file)
}

output "encrypted_named_value" {
  value = provider::az-confidential::encrypt_apim_named_value(
    var.content,
    {
      az_subscription_id  = "123421"
      resource_group      = "rg"
      api_management_name = "apim"
      name : "namedValue123",
    },
    {
      create_limit  = "72h"
      expires_after = 365
      num_uses      = 50
      provider_constraints = toset(["test", "acceptance"])
    },
    local.public_key
  )
}

```

Please refer to the [`encrypt_apim_named_value` function documentation](../functions/encrypt_apim_named_value.md)
for the description of the parameters the function accepts.

### Create ciphertext using `tfgen` tool

The ciphertext as well as a complete Terraform datasource template can be obtained using the `tfgen` command-line tool
(see [source code](https://github.com/aliakseiyanchuk/terraform-provider-az-confidential-tfgen).)
The prompt equivalent to the function invocation illustrated above is:
```shell
tfgen -pubkey [path to the public key] \
  -provider-constraints demo,acceptance \
  -num-uses 50 \
  apim named_value
```
The tool will prompt for the interactive content input. Further options can be obtained by `tfgen -help` and
`tfgen apim named_value -help` commands.

## Example Usage

```terraform
# ----------------------------------------------------------------------------
#
# Azure API Management Named Value Resource
#
# The resource allows importing pre-set named values into an API management
# service. Although the same can be achieved with Key Vault integration, in
# some cases this approach will prove more advantageous owing to the lowered
# churn of Key Vault objects.
#
# ----------------------------------------------------------------------------

resource "az-confidential_apim_named_value" "named_value" {
  content = <<-CIPHERTEXT
            H4sIAAAAAAAA/1TTT/d6SgDH8f08ivbuPYjE95y7SDQoEhplNzHk39CQ6NHf8/vufp/la/HZvf/9M92E
            trfan73I9KJfAXtG8EhOZVuOPytxu5HVjaIoCjDnvmTLH1IVUZJkRQFul5EmIDlhhKbkZ5V2jPDDyEpa
            8JMI/AanpCV03Hd0GBku6Tj8rIDPuqnMCPtLM9J2/4xkGEtagGjpyc8K9+WqxRQXvx88xS3JVhNu3gSA
            zrV7OQ+Vds133lmH85a3OWfzzo8BU1NPuslGRk6WCgMa8X3cO4WYeRw2En/o3kGUA9vk5MZn6hZNTlHC
            ZXGOtEqwFY0M0cSOtQdx5by7a2h9eYsf3DdmcryJ/Is9cYieCJCS4/r+mxVOKyH6vmUS5+hO/jEO2eZx
            CDnBr9x3M56JRpqyOmeTuKC1fqNouqaxWp0BJonPpjC6ake7zWDglQWTteN1mMkax2N+OnH5Yi9rv+L3
            AZZ8qhmXAeNXYG8fJ7dCQECm8zC26Q0xKXX2yJLv0l17XWY9e5Y0IptI8r/YfbbP4k4Ph30PjcrJwngR
            6HKqiQKI9+jhzVBfFx8KtvwJdqe1IcNmJ/iQaruUn+VA0PV2zqV5kNImNZ8YMkny6/F2xRYEfdy2dNtN
            no+912cKt1LRdHOCw63qCqNnndhdVfqE7jgIlbwy1axJM78upHoojughA5URr/uiZRwkXavG3YHT0S0q
            ZpHCSl+q7vPigqBGwnIdIDaLt4ad5alYxE01CfZ1D3bVPk7phZt2uX69P+vaVj/o6N6/UWnVH9Ux9FoY
            Ys7XzfSrrp9cEcR752s06MsT5ShEILkEifHCexoP2HpP+ee0HuxPsVPDjSrk7QZdRPhF5Kp8y+FytS5n
            9RZfxfJQHHqDCUQELBxc6xgRazvvpldqxbxDRREX4lENeU4PE77NWi6pYVP8B34LMz3j7+L+DwAA//+j
            T7ncigMAAA==
            CIPHERTEXT


  tags = [
    # Fill the tags as desired
    # "TagValue"
  ]

  # Confidential values created from the sensitive ciphertext are best kept secret, meaning that
  # these will be hidden on the Portal display
  secret = true

  # A display name of this named value. It doesn't play a role in the actual operation;
  # whereas it's great to give it a descriptive name. If it is not specified, it is
  # inferred from the name of the destination named value.
  # display_name = "confidential named value"

  destination_named_value = {
    # Specify a Azure subscription id where the APIM instance is created
    az_subscription_id = "...specify the subscription..."
    # Specify a Azure resource group  id where the APIM instance is created
    resource_group = "...specify the resource group name..."
    # Specify a Azure APIM service name
    api_management_name = "...specify the APIM service name..."
    # Specify the name this named value should use; may contain
    # only letters, digits, periods, dashes and underscores
    name = "...specify the APIM named value..."
  }
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `content` (String) Encrypted confidential content to create this resource
- `destination_named_value` (Attributes) Destination named value (see [below for nested schema](#nestedatt--destination_named_value))

### Optional

- `display_name` (String) Display name of this named value
- `secret` (Boolean) Whether this named value should be masked in the display in Azure portal
- `tags` (Set of String) Tags to place on this named value
- `wrapping_key` (Attributes) Wrapping key to use for key and secret unwrapping purposes (see [below for nested schema](#nestedatt--wrapping_key))

### Read-Only

- `id` (String) Identifier of the decryption operation

<a id="nestedatt--destination_named_value"></a>
### Nested Schema for `destination_named_value`

Required:

- `api_management_name` (String) API Management service name
- `az_subscription_id` (String) Azure subscription of the target APIM service
- `name` (String) Name of the named value to be created
- `resource_group` (String) Resource group of the target APIM service


<a id="nestedatt--wrapping_key"></a>
### Nested Schema for `wrapping_key`

Optional:

- `algorithm` (String) Algorithm to use for unwrapping secret/content encryption key; defaults to RSA OAEP 256; a sensible default that doesn't need to be changed
- `name` (String) Name of the wrapping key
- `vault_name` (String) Vault name containing the wrapping key
- `version` (String) Version of the wrapping key to use for unwrapping operations
