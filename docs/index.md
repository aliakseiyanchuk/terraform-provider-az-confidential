---
# generated by https://github.com/hashicorp/terraform-plugin-docs
page_title: "az-confidential Provider"
subcategory: ""
description: |-
  Azure Confidential provider automates importing sensitive secrets, keys, and certificates from Terraform
  code into Azure KeyVault. To achieve the confidentiality, the sensitive materials are encrypted using RSA/AES encryption.
  Furthermore, the provider never logs or stores the plain text in state.
  Authenticating Provider
  The preferred way of authenticating the provider is to set up the environment compatible with the
  azidentity.NewDefaultAzureCredential requirements. (You can read about this e.g. here https://learn.microsoft.com/en-us/azure/developer/go/sdk/authentication/authentication-overview.)
  For local development, the provider supports client credentials authentication that needs to be
  provided to the provider e.g. via variables.
  To get started with testing this provider, the following configuration could be added to your project:
  
  provider "az-confidential" {
    tenant_id       = var.az_tenant_id
    subscription_id = var.az_subscription_id
    client_id       = var.az_client_id
    client_secret   = var.az_client_secret
  
    labels              = ["demo", "test", "examples"]
    require_label_match = "provider-labels"
  
    default_destination_vault_name = var.az_default_vault_name
  
    default_wrapping_key = {
      vault_name = var.az_default_vault_name
      name       = var.az_default_wrapping_key
      version    = var.az_default_wrapping_key_version
    }
  }
  
  The required variables can be declared as follows:
  
  variable "az_tenant_id" {
    type = string
  }
  
  variable "az_subscription_id" {
    type = string
  }
  
  variable "az_client_id" {
    type = string
  }
  
  variable "az_client_secret" {
    type = string
  }
  
  variable "az_default_vault_name" {
    type = string
  }
  
  variable "az_default_wrapping_key" {
    type = string
  }
  
  variable "az_default_wrapping_key_version" {
    type = string
  }
  
  Labels and Tracking
  The provider has two mechanism that prevent accidental cross-environment copying or intentional duplication. These
  are labels and object tracking.
  Labelling
  A label is a string associated with the encrypted data at the moment the owner of the confidential data creates
  the encrypted message. There are two types of labels that can be associated with the ciphertext:
  A label derived from vault name and object name. It commands the provider to unpack the ciphertext only into
  the specified vault and object name, even if the enclosing Terraform code will later be changed.A label associated with the provider, which might be a good practice to detect and prevent confidential data used
  outside intended environments.
  The labelling behaviour is controlled by two provider properties:
  require_label_match controlling the degree of matching this particular provider requires; andlabels that are associated with this provider instance.
  Where require_label_match would be set to target-coordinate, a ciphertext of the object must be explicitly tagged
  with the output vault name and object name. Where require_label_match would be set to provider-labels, then the
  provider would process ciphertext tagged with either of the tags the labels parameter specifies.
  It is a good practice to ask the owner of the confidential data to re-encrypt the corresponding data
  if a mismatch is detected.
  Object Tracking
  Object tracking is a feature which, as its name implies, tracks the use of the ciphertexts and allows each
  ciphertext to be unpacked exactly once. I.e. if a resource is deleted and then added again, the second deployment
  will be rejected as it would be a duplicate. This feature is based on UUID identifier that is cryptographically
  added to the ciphertext when it is created.
  The first version implements a basic, file-based tracking suitable for local testing. To enable this feature, set file_hash_tracker configuration
  and specify the file where the data will need to be kept. Future versions might add the support e.g. for tracking
  this data in databases.
  For production use, the provider supports Azure Storage Account-base tracking. This requires the
  user of the provider:
  to create a storage account (or designate any existing storage account);to create a table within that storage account;grant Storage Table Data Contributor role to the IAM account used by the provider.
  The configuration required for this could look e.g. as follows:
  
  provider "az-confidential" {
    # ... other configuration properties
  
    storage_account_tracker = {
      account_name = ".. an account name"
      table_name = ".. a table name"
      partition_name = ".. a partition name"
    }
  }
---

# az-confidential Provider

Azure Confidential provider automates importing sensitive secrets, keys, and certificates from Terraform 
code into Azure KeyVault. To achieve the confidentiality, the sensitive materials are encrypted using RSA/AES encryption.
Furthermore, the provider never logs or stores the plain text in state.

## Authenticating Provider

The preferred way of authenticating the provider is to set up the environment compatible with the
`azidentity.NewDefaultAzureCredential` requirements. (You can read about this e.g. [here](https://learn.microsoft.com/en-us/azure/developer/go/sdk/authentication/authentication-overview).)

For local development, the provider supports client credentials authentication that needs to be
provided to the provider e.g. via variables. 
To get started with testing this provider, the following configuration could be added to your project:
```terraform
provider "az-confidential" {
  tenant_id       = var.az_tenant_id
  subscription_id = var.az_subscription_id
  client_id       = var.az_client_id
  client_secret   = var.az_client_secret

  labels              = ["demo", "test", "examples"]
  require_label_match = "provider-labels"

  default_destination_vault_name = var.az_default_vault_name

  default_wrapping_key = {
    vault_name = var.az_default_vault_name
    name       = var.az_default_wrapping_key
    version    = var.az_default_wrapping_key_version
  }
}
```

The required variables can be declared as follows:
```terraform
variable "az_tenant_id" {
  type = string
}

variable "az_subscription_id" {
  type = string
}

variable "az_client_id" {
  type = string
}

variable "az_client_secret" {
  type = string
}

variable "az_default_vault_name" {
  type = string
}

variable "az_default_wrapping_key" {
  type = string
}

variable "az_default_wrapping_key_version" {
  type = string
}
```

## Labels and Tracking
The provider has two mechanism that prevent accidental cross-environment copying or intentional duplication. These 
are labels and object tracking.

### Labelling
A label is a string associated with the encrypted data at the moment the owner of the confidential data creates
the encrypted message. There are two types of labels that can be associated with the ciphertext:
- A label derived from vault name and object name. It commands the provider to unpack the ciphertext **only** into
  the specified vault and object name, even if the enclosing Terraform code will later be changed.
- A label associated with the provider, which might be a good practice to detect and prevent confidential data used 
  outside intended environments.

The labelling behaviour is controlled by two provider properties:
- `require_label_match` controlling the degree of matching this particular provider requires; and
- `labels` that are associated with this provider instance.

Where `require_label_match` would be set to `target-coordinate`, a ciphertext of the object must be explicitly tagged
with the output vault name and object name. Where `require_label_match` would be set to `provider-labels`, then the
provider would process ciphertext tagged with either of the tags the `labels` parameter specifies.

> It is a good practice to ask the owner of the confidential data to re-encrypt the corresponding data
> if a mismatch is detected.

### Object Tracking
Object tracking is a feature which, as its name implies, tracks the use of the ciphertexts and allows each 
ciphertext to be unpacked *exactly once*. I.e. if a resource is deleted and then added again, the second deployment
will be rejected as it would be a duplicate. This feature is based on UUID identifier that is cryptographically 
added to the ciphertext when it is created.

The first version implements a basic, file-based tracking suitable for local testing. To enable this feature, set `file_hash_tracker` configuration
and specify the file where the data will need to be kept. Future versions might add the support e.g. for tracking
this data in databases.

For production use, the provider supports Azure Storage Account-base tracking. This requires the 
user of the provider:
- to create a storage account (or designate any existing storage account);
- to create a table within that storage account;
- grant `Storage Table Data Contributor` role to the IAM account used by the provider.

The configuration required for this could look e.g. as follows:
```hcl
provider "az-confidential" {
  # ... other configuration properties

  storage_account_tracker = {
    account_name = ".. an account name"
    table_name = ".. a table name"
    partition_name = ".. a partition name"
  }
}
```

## Example Usage

```terraform
provider "az-confidential" {
  # Configure explicit client credentials
  tenant_id       = var.az_tenant_id
  subscription_id = var.az_subscription_id
  client_id       = var.az_client_id
  client_secret   = var.az_client_secret

  # Ensure that the provider will only unwrap the confidential objects
  # that are intended for this provider.
  labels              = ["test", "demo", "experimentation"]
  require_label_match = "provider-labels"

  default_wrapping_key = {
    vault_name = var.az_default_vault_name
    name       = var.az_default_wrapping_key
    version    = var.az_default_wrapping_key_version
  }

  # Track the objects created in storage account to make sure that
  # all confidential objects are unwrapped exactly once across all of your
  # intended installation.
  storage_account_tracker = {
    account_name   = var.az_storage_account_name
    table_name     = var.az_storage_account_table_name
    partition_name = var.az_storage_account_table_partition
  }

  default_destination_vault_name = var.az_default_vault_name
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `default_destination_vault_name` (String) Default destination vault name where decrypted secrets need to be placed

### Optional

- `client_id` (String) Client ID to use
- `client_secret` (String) Client secret to use
- `default_wrapping_key` (Attributes) Default location of the wrapping key (see [below for nested schema](#nestedatt--default_wrapping_key))
- `disallow_resource_specified_wrapping_key` (Boolean) Disallow individual resources to specify resource-level unwrapping keys
- `file_hash_tracker` (Attributes) Configures local file being used to track created objects (see [below for nested schema](#nestedatt--file_hash_tracker))
- `labels` (Set of String) Provider labels
- `require_label_match` (String) Match required between unwrapped ciphertext and labels of this provider
- `storage_account_tracker` (Attributes) Configures Azure Storage Account table to be used to track objects created (see [below for nested schema](#nestedatt--storage_account_tracker))
- `subscription_id` (String) Subscription ID to use
- `tenant_id` (String) Tenant ID to use

<a id="nestedatt--default_wrapping_key"></a>
### Nested Schema for `default_wrapping_key`

Optional:

- `algorithm` (String) Encryption algorithm to be used for unwrapping operations
- `name` (String) Name of the wrapping key
- `vault_name` (String) Vault name containing the wrapping key
- `version` (String) Version of the wrapping key to be used for unwrapping operations


<a id="nestedatt--file_hash_tracker"></a>
### Nested Schema for `file_hash_tracker`

Required:

- `file_name` (String) File on a local machine where to track created objects


<a id="nestedatt--storage_account_tracker"></a>
### Nested Schema for `storage_account_tracker`

Required:

- `account_name` (String) Storage account name to use
- `partition_name` (String) Partition name to use
- `table_name` (String) Table name to use
